h1. Introduction

!logo.gif!

Thank you for your interest in *j*Billing! 

In this document, we will explore in detail the integration features of jBilling that help external applications to 
to connect with the billing infrastructure provided by *j*Billing and perform seamless interaction.

*j*Billing provides a comprehensive set of GUI enabled features for viewing, managing, and keeping 
track of all billing and invoicing operations for your organization. Along with its core functionality, *j*Billing 
provides a rich integration layer that enables your applications to tightly interact with the billing infrastructure and 
streamline all billing-related operations into your organization's work flow.

This document contains valuable information for application developers and architects what want to
integrate *j*Billing with their own systems, or perform actions in *j*Billing from external applications.
Here, you'll find a comprehensive reference to the *j*Billing Web Services APIs and an introductory examples including the 
glue code that explains how many of these integration tasks can be accomplished.

h2. Requirements

*j*Billing provides its 'integration' services in three distinct flavors: 

# SOAP (Simple-Object Access Protocol)
# Hessian/Burlap (lightweight web service protocols) 
# Spring HTTP Invoker

In order to fully acquire, and take advantage of, the information contained herein, you may
need to have at least a basic grasp of what [SOAP|http://www.w3schools.com/soap/soap_intro.asp] is and how it works. 

{note}
To learn about Hessian and Burlap, visit their homepage at [http://hessian.caucho.com|http://hessian.caucho.com] 
{note}

SOAP is a XML-based 'programming language independent' protocol for exchanging information over HTTP. Therefore, it enables diverse 
platforms to communicate without bias. Since *j*Billing implements its services through SOAP, even business applications running on 
non-Java platforms can communicate to or integrate with *j*Billing because of its SOAP support.

Hessian is a fast binary web services protocol that works over HTTP, with implementations available in a number of languages. 
Like SOAP, it has the advantages of being firewall friendly and the ability to make use of authentication and encryption, yet it 
is similar in speed and bandwidth performance to Java RMI. Hessian 2 provides even much better performance as compared to its previous version.
Burlap is closely related to Hessian except that it uses human readable XML instead of binary messages. However, neither Hessian nor 
Burlap require an externally defined WSDL file, which is required by SOAP.

Most examples provided in this document are explained in Java, therefore, some knowledge of Java programming language 
would prove very useful. There is still a small section dedicated to implementing *j*Billing integration in other
languages such as C#.NET and PHP. Please refer to your language/platform's documentation in order to determine
what specific SOAP support it provides, and how to make use of it (specifically, how to call remote SOAP services, 
and how to pass parameters and decode the returned values).

It is also recommended that you have a basic understanding of *j*Billing's functionality and usage. 
You can find this information in other documents available from *[jBilling User Guide|guide:userGuide]* and *[Getting Started|http://www.jbilling.com/documentation/getting-started-with-jbilling]*.
Knowing how the program works is of course necessary to understand the scope and usage of each service call. Last but not least, 
you will need a running copy of *j*Billing in order to execute the examples contained in this document. 
Following the *Trend* tutorial on the *[Getting Started|http://www.jbilling.com/documentation/getting-started-with-jbilling]* document is also necessary to generate some of the data required for the
examples to work.

h2. The Need for Integration

Applications need to interface with other applications. More so, for a billing application that contains significant information 
about things like Customer Status, Payments Overdue, Subscriptions for Customer etc. This information is likely to be important inputs for 
decision making in other business applications and processes. 

!need_for_integration.png!

A self-contained billing application, on the other hand, has another big drawback: 
to keep it updated, you would need a separate data-entry process that feeds the billing data from your system into the billing application. 
This is both time and resource consuming. For example:

Let's suppose you own a website with a member's area. In order to access the member
area, the customer would need to pay a monthly fee. If the billing data is kept separately,
when a new user subscribes to the website, the billing data would need to wait until
somebody enters data into the billing application, and after the payment is cleared the
same person would need to update the website in order to grant access to the user.

The manual authorization process would have a heavy impact on the site's functionality.
Even if there are instant payment options, such as credit cards, the user would have to
wait for a manual operation to take place before being granted access to the service he
paid for.

*j*Billing solves this problem by rendering common billing and data retrieval operations
available to your system via service calls. With a relatively small programming effort, you
can integrate the billing application with your own systems or business processes, so that when the new user
signs in, you can instantly pass the data to the billing application, have the payment
cleared and grant access without the need for manual operations.

As we'll see in the following sections, integration services in *j*Billing are almost as
comprehensive as the billing functionality provided through the standard web interface.
Using the integration layer, you can retrieve lots of useful data from *j*Billing, as well as
_create_, _update_ or _delete_ Users, Items, Orders and Invoices.

h2. Preparing *j*Billing for Integration

h3. Configuring and Using a Remoting Method

h4. Configuration

jBilling Integration services are configured as remote beans in @descriptors\spring\jbilling-remote-beans.xml@ file.
This file contains three entries with Spring Bean ID starting with *'apiClient'*, one for each of the 3 integration methods 
available in jBilling out-of-the-box. Thus, *j*Billing comes pre-configured with *Hessian/Burlap* (Bean Id: _apiClient_), *SOAP* (Bean Id: _apiClient2_) and 
*Spring HTTP Invoker* (Bean Id: _apiClient3_) beans, ready to accept connections from clients. Unlike others, Spring HTTP Invoker is an unauthenticated 
protocol. Therefore, in this case, we must configure an alternate authentication filter that sets the credentials to be 
used when making non-authenticated API calls. 

{code}
<xml ...>
<beans ....>
	
	<!-- Hessian Remote WS Bean -->
	<bean id="apiClient" ... >
		<property .../>
	</bean>
	
	<!-- SOAP WS Bean -->
	<jaxws:client id="apiClient2" ... />
	
	<!-- Spring HTTPInvoker Remote WS Bean -->
	<bean id="apiClient3" ... >
		<property .../>
	</bean>
	
</beans>
{code}

See the section *Enabling/Disabling authentication for jBilling web services* section below for information regarding this.

!integration.png!

If other remoting methods are not being used, their definition beans may be commented out from this file to give a small 
improvement in *j*Billing startup time and memory footprint. This can be done by commenting the appropriate bean definitions in the file
@descriptors\spring\jbilling-remote-beans.xml@

Additionally:

* For disabling *Hessian/Burlap*, delete the appropriate Web Services mapping from @descriptors\web\jbilling-servlet.xml@. 
* For disabling *SOAP*, search for and delete any sections of XML that reference *'cxf'* in @descriptors\web\web.xml@.

h3. Securing Integration Access

h4. Overview

While integration services could be an extremely useful feature, they do bring up some
security concerns you'll need to take into account. It is critical that the services are not
exposed to external parties, otherwise it could be possible for them to invoke the same
functionality you're using (and, most probably, you don't want an outsider to be able to
create a payment or invoice).

Therefore, the integration services should be exposed only to properly authorized
parties. This is, at least in part, guaranteed by *j*Billing, since by default it requires a client
application to identify itself via a user name/password pair, before servicing any of its
requests. It would also be important to transmit all data over a secure channel, which
can be accomplished by using the SOAP or Hessian/Burlap calls over an SSL tunnel,
something we'll cover shortly.

Ideally, the web services would be exposed only to the server(s) that require it, and any
other parties should be excluded. This can be accomplished by using a firewall
application that limits the IP addresses that have access to *j*Billing's integration services.
Please refer to the documentation of the Operating System or platform in which your
copy of *j*Billing is to run, in order to have some information on how to restrict access to
specific TCP ports in your system.

It is also recommended that all service calls are performed by means of an encrypted
channel, as provided by the SSL (Secure Socket Layer) protocol. This effectively avoids
any threats related to unauthorized interception or decryption of the service calls. SSL
also ensures that the party you're engaging communication with is actually your intended
recipient, nullifying any impersonation attempts.

In order to determine if the party engaged in communication is actually who it is
pretending to be, SSL uses certificates. Therefore, in order to establish an SSL
connection to *j*Billing, it could be required to have a copy of *j*Billing's certificate in your
development and production systems.

h4. Enabling/Disabling authentication for *j*Billing web services

By default, all calls to *j*Billing must be authenticated. In most cases, this is the desired
behavior. If Spring HTTP Invoker is used to make calls to *j*Billing, authentication is not available. 
If the *j*Billing server is called by clients within an internal network secured from outside access, 
it maybe preferable to disable authentication to give a slight increase in performance. 

If SOAP or Hessian/Burlap are being used, this can be done as follows:

* Extract the *j*Billing web archive @jbilling\webapps\billing.war@
* Open the file @descriptors\web\web.xml@ for editing
* Comment out or delete the XML that refers to *Web Services Authentication Filter*. This includes one <filter> tag and two <filter-mapping> tags. Save the file and recreate (zip) the web archive.

h4. Enabling/Disabling company security checks

If only one company is using the *j*Billing installation, unnecessary security checks, which
make sure one company is not accessing another company's data, can be disabled to
further increase performance. To disable the check, edit the following file:

@./grails-app/conf/spring/resources.xml@

Comment out or delete the two XML beans under the section *AOP: Security / Logging*:
Bean ids *webServicesSecurityAdvice* and *webServicesSecurityAdvisor*).

h4. Enabling SSL for *j*Billing web services

Since web services run on HTTPS, for *j*Billing this is actually managed by Tomcat. Tomcat is the web server that 
comes with the *j*Billing distribution. Thus, the first step is to enable SSL in the Tomcat configuration. This is 
explained in the *Security* chapter of the *[jBilling User Guide|guide:userGuide]*. Please refer to that document. 
Once you can use your standard web client over SSL, you can immediately start doing all the web
services communication through HTTPS, effectively securing your web services. A further step is to force all 
the web services communication over SSL. To achieve that extract the billing web archive:

@jbilling\webapps\billing.war@ and edit the file: @descriptors\web\web.xml@

Notice that there is already a section at the bottom to force HTTPS, but it is commented.
Uncomment the XML tag *<security-constraint>* and its contents to force HTTPS.
It will use the SSL certificate that Tomcat is using to secure the standard web client.
Recreate the web archive (compress with a zip utility program) when done.

h3. Setting up *j*Billing to accept external calls

As mentioned earlier, *j*Billing will not accept all external calls it gets, but will require the
caller to identify itself with a user name and password in order to service the request.
Otherwise, the request will receive an error in response. This is a simple but effective
measure that improves overall security. Of course, this also means you (or the system
administrator) will need to set up an account in *j*Billing that will be authorized to perform
external calls.

Once you've followed the *[Getting Started|http://www.jbilling.com/documentation/getting-started-with-jbilling]* 
tutorial and created the initial billing entity, the user name and password you entered in the entity setup screen will represent the
user name and password of *j*Billing's administrator account. You can grant access to this administrator account 
(or any other account you create for this purpose) to connect remotely and perform service calls.

In order to do so, you'll need to enter *j*Billing's database, and annotate the +User ID+ of the
account you wish to authorize for external connection. This number can be obtained
from the @BASE_USER@ table, you can retrieve it with a simple SQL query:

{code}
SELECT USER_ID FROM BASE_USER WHERE USER_NAME = 'your-username';
{code}

Once this number is known, you can proceed to activate external calls permission by
adding a line in the @PERMISSION_USER@ table. The @PERMISSION_ID@ contains the code for
web services, which is *120* by default. The SQL query that does the insertion is:

{code}
INSERT INTO PERMISSION_USER(ID, PERMISSION_ID, USER_ID, IS_GRANT) VALUES
(SELECT MAX(ID)+1 FROM PERMISSION_USER, 120, <your-user-id>, 1);
{code}

The ID for the @PERMISSION_USER@ table is obtained by finding the largest @ID@ number
already in use and adding 1. The @IS_GRANT@ field contains a boolean value, if it equals
'0', the permission is not granted, if it is assigned '1', the permission is granted.
Assuming the +User ID+ obtained in the previous step was '1', the query would be:

{code}
INSERT INTO PERMISSION_USER(ID, PERMISSION_ID, USER_ID, IS_GRANT) VALUES
(SELECT MAX(ID)+1 FROM PERMISSION_USER, 120, 1, 1);
{code}

Now the administrator user is allowed to perform external calls. Note that you'll need to
specify the user name and password in the caller program.

{note}
Since *j*Billing is not tied to a specific database program, it could be possible (but
highly unlikely) that your specific database does not support the queries indicated above.
Please consult your vendor's manual on how to query and insert data in your database,
if the above SQL instructions do not happen to work in your specific system.
{note}

h2. Connecting to *j*Billing

h3. SOAP

Once it is properly configured, you'll need to address all integration calls to *j*Billing's web
service endpoint. This endpoint is accessible at the same server where *j*Billing was
deployed, in a specific URL address, which follows this form:

@http://localhost:8080/jbilling/services/api@

You can query the service's WSDL (Web Service Description Language) file. It consists
of an XML containing a description of the available service calls and parameters used by
each call, and could be useful if your programming platform provides a way of
automatically generating code for service calls from a WSDL, or you have a tool that can
perform test calls (such as *SoapUI*).

To query the WSDL file, you'll need to append the ?wsdl parameter to the call, for
example:

@http://localhost:8080/jbilling/services/api?wsdl@

Below is a snapshot of the WSDL showing operation *getLatestInvoice*:

{code}
<?xml version="1.0" encoding="UTF-8"?>
	<wsdl:definitions xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" 
		xmlns:tns="http://jbilling/" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:ns2="http://schemas.xmlsoap.org/wsdl/soap/http" 
		xmlns:ns1="http://util.server.jbilling.sapienter.com/" targetNamespace="http://jbilling/" name="ApiServiceService">
		
		<wsdl:import namespace="http://util.server.jbilling.sapienter.com/" 
			location="http://localhost:9090/jbilling/services/api?wsdl=IWebServicesSessionBean.wsdl">
		</wsdl:import> 

		<wsdl:binding type="ns1:IWebServicesSessionBean" name="ApiServiceServiceSoapBinding">
			<soap:binding transport="http://schemas.xmlsoap.org/soap/http" style="document"/> 
			...
			<wsdl:operation name="getLatestInvoice"> <soap:operation style="document" soapAction=""/> 	
				<wsdl:input name="getLatestInvoice"> <soap:body use="literal"/></wsdl:input>
				<wsdl:output name="getLatestInvoiceResponse"> <soap:body use="literal"/></wsdl:output>
				<wsdl:fault name="SessionInternalError">
					<soap:fault name="SessionInternalError" use="literal"/> 
				</wsdl:fault> 
			</wsdl:operation>
			...
		</wsdl:binding>
	</wsdl>
</xml>
{code}

h3. Hessian/Burlap

The Hessian service URL is in the following form:

@http://localhost:8080/jbilling/hessian/ApiService@

Similarly for Burlap:

@http://localhost:8080/jbilling/burlap/ApiService@

h3. Spring HTTP Invoker

The Spring HTTP Invoker service URL is in the following form:

@http://localhost:8080/jbilling/httpinvoker/ApiService@

h1. Integrating *j*Billing to your Application

h2. Overview

This section discusses the approaches available for integrating *j*Billing in your
application. While *j*Billing exposes a unique Web Services integration API, there are
other ways of interacting with that layer too, based on the technology available to the
application developer in the target system. 

Therefore, if your application is written in Java or at has a way of interfacing with Java,
then the simplest way of integrating *j*Billing with your application is by making use of the +jBilling
Client API+. The +jBilling client API+ is a pure Java API that another Java program can directly call/use.

Service calls can also be performed by means of plain SOAP or Hessian/Burlap calls. This type 
of interaction is useful for those situations in which you cannot use Java as your programming 
language (either because your server does not support it or because your application has already 
been written in another programming language). 

Generally, it easier to use the *j*Billing API than hard-coding SOAP or Hessian/Burlap calls directly.

We'll now examine the above possibilities and also see some sample code for each instance.

h2. The *j*Billing Client API

The *j*Billing Client API is a library that contains a set of Java classes that wrap the actual
calls that are made to *j*Billing. This simplifies the interaction with *j*Billing as it completely
hides the low level connection logic, which you would otherwise need to deal with either
directly or via a third party library (such as *Axis* or *CXF*). Being Java classes, you must
be working in Java or have a way of invoking Java functions from your programming language.

{note}
The exact same function calls exposed as Web Services are available through the API. It simply
acts as a wrapper.
{note}

As a sub-project of *j*Billing, the *j*Billing client API has a few extra advantages. It provides a standardized 
interface to *j*Billing; so, even if in the future the SOAP interfaces change or new parameters are added, your 
code will require little or no modification at all to adapt to those changes. Last, but not least, its
code is Open Source, so that you can get down to the implementation details if needed.

The +jBilling client API+ is well equiped to perform service calls to *j*Billing in four distinct ways: 

# By means of standard SOAP calls
# Through Hessian calls
# Through Burlap calls
# Through Spring HTTP Invoker calls

, of which, you may choose one that best meets your project requirements. 

Hessian generally has the best features on offer: a fast binary protocol comparable in speed to Java RMI 
(for Hessian 2), HTTP based for access through restrictive firewalls, the possibility of using HTTP authentication 
and SSL encryption, and library implementations in a number of languages.

SOAP still enjoys the best Multi-programming language support. 

The specific calling protocol is hidden in the library's implementation and can be changed to use any one of the 
above by simply changing a parameter, and by making the required libraries available.

h3. The advantages of using *j*Billing client API

As discussed earlier, the +jBilling Client API+ is by far the most convenient means of integrating with *j*Billing as compared to 
handling SOAP/Hessian calls through custom programming. Here are few additional reasons to support this argument:

First, the client implementation is *cleanly separated from the underlying transport protocol* used. 
Your code does not change if you switch from SOAP calls to Hessian calls. Also, if other protocols are added 
in the future, you'll be able to use them as needed without changing your integration code. 
An example was *j*Billing 2's introduction of Hessian/Burlap support.

Secondly, the API absorbs *most of the housekeeping activities* you need to perform when using a SOAP library 
(such as setting up the call parameters and data types). You will just need to instantiate and populate the correct 
data structures that will contain the input and output data, and call the API to take care of the rest.

Third, using this API will allow you to use advance deployment features, such as *clustering, load balancing and fail over*. 
Since the API is a layer in between the client (your application), and the server (*j*Billing), it is the ideal place to
abstract different lay-outs of the server deployment, keeping a simplified view from the client. Using these features 
will simply mean a change of the API's configuration files, without changing any code.

To get an idea of how simple it can be to perform the integration calls, take a look at the following code. 
The first example calls *j*Billing (using the *j*Billing client API) to perform a simple customer login sequence 
(more on this later):

{code}
import com.sapienter.jbilling.server.util.api.JbillingAPI;
import com.sapienter.jbilling.server.util.api.JbillingAPIFactory;
import com.sapienter.jbilling.server.user.UserWS;

Integer userId = null;
JbillingAPI api = JbillingAPIFactory.getAPI();
try {
	userId = api.getUserId(username);
	UserWS userData = api.getUserWS(userId);
} catch (Exception e) {
	System.out.println("Invalid username: the user does not exist!");
}
{code}

Compare the above code with the following example, which performs exactly the same
calls but using the Apache Axis library:

{code}
import javax.xml.namespace.QName;
import javax.xml.rpc.ParameterNode;
import org.apache.axis.client.Call;
import org.apache.axis.client.Service;
import org.apache.axis.encoding.ser.BeanDeserializerFactory;
import org.apache.axis.encoding.ser.BeanSerializerFactory;

Service service = new Service();
Call call = (Call) service.createCall();
call.setTargetEndpointAddress("http://localhost:8080/jbilling/services/api");
call.setUsername("myusername");
call.setPassword("mypassword");
call.setOperationName("getUserId");
call.setReturnClass(UserWS.class);

QName qn = new QName("http://www.sapienter.com/billing", "UserWS");
BeanSerializerFactory ser1 = new BeanSerializerFactory(
UserWS.class, qn);

BeanDeserializerFactory ser2 = new BeanDeserializerFactory(
UserWS.class, qn);
call.registerTypeMapping(UserWS.class, qn, ser1, ser2);

try {
	Integer userId = call.invoke(new Object[] { username });
	UserWS userData = call.invoke(new Object[] { userId });
} catch (Exception e) {
	System.out.println("Invalid username: the user does not exist!");
}
{code}

Therefore, a good part of the latter deals with the setup of the Axis SOAP calls, i.e. more housekeeping than 
the actual logic of the call. Whereas, the *j*Billing Client API example works just as well with Hessian. Simply change an XML
file, no coding required.

{note}
Take advantage of the Client API. You will probably welcome its simplicity and convenience.
{note}

h3. Using the *j*Billing Client API

The Client API classes are packaged in the @jbilling_api.jar@ file that is located in your *j*Billing
distribution. 

The API also makes use of several third-party libraries, such as the Log4j and Commons Logging - for logging infrastructure,
Spring - for configuration and remoting, Apache CXF - for SOAP API calls, and Hessian - for Hessian/Burlap support. Thus, you'll need 
the @log4j.jar@, @commonslogging.jar@ and @spring.jar@ files in your class path, if your project does not already include them. 

These files are in the @WEB-INF\lib\@ directory of the @jbilling\webapps\billing.war@ web archive, as well.

The API also requires a configuration file, the @jbilling\conf\jbilling-remote-beans.xml@ file, which needs to be added to
your project. This file defines some important parameters that the API will later retrieve and use. More on this in the next section.

Depending on the underlying transport protocol you choose to use (Hessian or SOAP), the program will require other libraries. 
These requirements are explained in detail in the sections below. Once you have set up your environment for using the *j*Billing Client API, 
you can use the library by using a factory method to retrieve an API interface, which you'll later use to place the integration call.
You can retrieve an interface to the API in the following manner:

{code}
JbillingAPI api = JbillingAPIFactory.getAPI();
{code}

The @JbillingAPI@ object allows you to place integration calls directly. Each call performs a specific functionality. 
For example:  @api.getUserId()@ retrieves the *j*Billing User ID of a user, given the user-name. Obviously, each call requires different
parameters and returns different data, according to its use.

The rest of the API library contains classes that define the parameters you can use as input and receive as output from the service calls. 
For example, the [UserWS|api:com.sapienter.jbilling.server.user.UserWS] class contains a set of data regarding the *j*Billing user, such as the user name, password, date of creation, etc. 
As usual in Java, most of these properties are accessible using the getter and setter methods, such as @getUsername()@ or @setPassword()@.
Most of the integration effort goes into setting values into these structures and passing them to the appropriate service call. 
For example, you'll fill a [UserWS|api:com.sapienter.jbilling.server.user.UserWS] structure and pass it to the @createUser()@ service call. Most of the API follows this simple logic.

h3. Configuration

The @jbilling\conf\jbilling-remote-beans.xml@ file contains some fundamental parameters that define the connection to the *j*Billing server you wish to
communicate with. This file is required by the *j*Billing API library for all connection alternatives.

Each connection option is contained within XML bean configuration tag with *id="apiClient"* as an attribute. There are four example configuration beans, one for
each of the four different remoting protocols. Only one bean should be enabled/uncommented at any given time, which is the configuration the API will use. The note/comment above each
bean indicates which protocol it configures. Common properties to the SOAP, Hessian and Burlap protocols: username and password.
these values must correspond to a valid account in jbilling that has been granted permission to execute web service calls.
Properties and setup specific to each remoting method are detailed in the sections below.

h3. The SOAP (CXF) Web Services Method

When using this protocol for service calls from the *j*Billing Client API, you will need to include the CXF library (*cxf.jar*), which provides support for SOAP. 
A few support libraries are also required: *XmlSchema.jar*, *wsdl4j.jar*, *FastInfoset.jar* and *neethi.jar* You can find all the required .jar files in your 
*j*Billing distribution, in the @WEB-INF\lib\@ directory of the @jbilling\webapps\billing.war@ web archive. All these libraries will need to be added 
to your application's class path in order to be usable by the API. 

While SOAP is a solid way of communicating with remote applications, it requires the parties to exchange XML files when the service call takes place. 
These files can be quite massive, and a great deal of time is wasted in serializing parameters into an XML, and deserializing the response. 
For this reason, SOAP is relatively inefficient when it comes to implementing fast service calls. Therefore, you're advised to use Hessian or Spring HTTP Invoker 
service, since they are much faster.

h4. Properties

* address - This is the URL that points to the jbilling Web Services endpoint (as discussed in the *Connecting to jBilling* section of the *Preparing jBilling for
Integration* chapter of this document). As a part of this property, you may specify the correct protocol (either http or https) and the port number, if it differs 
from the standard port (which is 80 for HTTP and 443 for HTTPS). 

For example:

{code}
address="http://localhost:8080/jbilling/services/api"
{code}

h3. The Hessian/Burlap Method

The Hessian and Burlap versions of the Client API provides a different communication protocol. Hessian messaging is in binary format and therefore provides 
faster calls, whereas Burlap allows XML messages to be used in the cases where human readability is needed. If using Hessian or Burlap, @hessian.jar@ is required, 
and can be found in the @WEBINF\lib\@ directory of the @jbilling\webapps\billing.war@ web archive.

h4. Properties

* serviceUrl - This is the Hessian Service Url that *j*Billing exposes (as discussed in *Connecting to *j*Billing* section of the *Preparing *j*Billing for Integration*
 chapter of this document)

{code}
<property name="serviceUrl" value="http://localhost:8080/jbilling/hessian/ApiService"/>
{code}

* serviceInterface - This is the business interface that exposes the business functionality

{code}
<property name="serviceInterface" value="com.sapienter.jbilling.server.util.IWebServicesSessionBean"/>
{code}

* hessian2 - This is a true/false Hessian specific property. It indicates whether Hessian should use the newer version 2 protocol, which is faster than version 1. 
Although Hessian 2 is still a draft specification, a value of true is generally recommended for performance

h3. Spring HTTP Invoker Method

Spring HTTP Invokers provide a powerful mechanism of remote component communication. On the server side, services are exposed on top of Spring's infrastructure,
using the Spring bean configuration mechanism. On the client side, Spring provides proxy capabilities that allow access to HTTP Invoker exposed 
services via a business interface. Since it is unauthenticated, you must configure an alternate authentication filter that sets the credentials to be used
when making non-authenticated API calls.

This business interface is specified as a property of the [HttpInvokerProxyFactoryBean|api:org.springframework.remoting.httpinvoker.HttpInvokerProxyFactoryBean].
This is pre-configured in *j*Billing to use [IWebServicesSessionBean|api:com.sapienter.jbilling.server.util.IWebServicesSessionBean]

h4. Properties

* serviceUrl - The service URL RMI should connect to (as defined in the *Connecting to *j*Billing* section of the *Preparing *j*Billing for Integration* 
chapter of this document)

For example:

{code}
<property name="serviceUrl" value="rmi://localhost:1199/RmiService"/>
{code}

* serviceInterface - This is the business interface that exposes the business functionality

{code}
<property name="serviceInterface" value="com.sapienter.jbilling.server.util.IWebServicesSessionBean"/>
{code}

h2. Integration with non-Java Applications

If your current application program is not based on the Java platform/language, you can still integrate your system with 
*j*Billing via direct SOAP calls. The beauty of SOAP is that it is independent of any particular language or framework in order to be usable. 
SOAP is available for many, if not all, of the programming languages commonly used for Web. In this document, we've limited ourselves to 
provide two of the most used programming languages for Web applications, besides Java i.e. C#.NET and PHP. Both provide SOAP support. 
If your system of choice is not one of these, please refer to your language's documentation for clues on how to use SOAP service calls 
effectively. You can however use these examples as a guideline on how to perform specific operations with *j*Billing.

The provided examples perform the same login sequence as seen in an earlier section of this document, but implementing it in each of the 
languages and platforms. Once the implementation in your specific language is clear, we advise you to follow the *Integration Tutorial* 
as well, since it provides useful insight into the purpose of some of the most used web service calls. This information should be 
of interest even if your system is not built on Java, as it explains the purpose of the calls, rather than their specific Java implementation.

h3. Integration with C# .NET

C# .NET provides seamless SOAP support, which requires no extra resources to be added to your application's execution environment. 
Please refer to the MSDN resources for latest information on what support options you have.

The difficult part in implementing SOAP on C# is to map the input and output parameters of the web call into appropriate data structures. Since there are many different calls, it
quickly gets difficult to create all the necessary classes.

{note}
Therefore, a handy utility, distributed as part of the Visual Studio&reg; distribution, is the @wsdl.exe@. This utility takes care of 
converting a WSDL file into appropriate data structures and creates an output file that contains a class that performs all web service
calls. You can find this command line tool in the *Visual Studio 8\SDK\v2.0\Bin* directory of your Visual Studio installation. 
Consult your Visual Studio documentation or just call *wsdl.exe* with no parameters to obtain some information on how to invoke this
tool and what parameters are acceptable.

If you use *SoapUI*, an Open Source tool for testing and handling web services, you can also set this program to generate the necessary 
.NET files (it supports generation of Managed C++, VisualBasic and J# code, as well as C#). Simply indicate the location of
the above mentioned wsdl.exe tool in your system in the Preferences dialog, connect to the *j*Billing web service url (as defined earlier)
 from SoapUI, and click on *Tools -> .NET 2.0 Artifacts* in the main menu. You'll be presented with a set of generation
options (WSDL file to use as input, output directory, the user name and password to pass to the service, etc.).
{note}

Once the class containing all the web service definitions has been generated (which will be named @WebServicesSessionLocalService.cs@), 
it is a simple matter of using the generated class in your code, in a way that is akin to the *j*Billing Client API for Java: 

{code}
using WebServicesSessionLocalService;

// create the interface instance of the class.
WebServicesSessionLocalService service = new WebServicesSessionLocalService();
int userId = service.getUserId(username);
if (userId > 0) {
	UserWS userData = service.getUserWS(userId);
}
{code}

h3. Integration with PHP

PHP provides SOAP support via an add on library (distributed with PHP itself). You'll need to activate the library support in your 
*PHP.INI* file and probably need a library file (libxml) to be present in your system in order to use the SOAP support (refer to the
PHP manual for details on how to activate SOAP support).

In order to automate the generation of input and output parameters for your SOAP request, you may use the PEAR library, which comes with 
the default PHP installation (unless you've used the @--without-pear@ configuration option during installation).

PEAR can generate the PHP code for the data classes or it can generate the classes on the fly for immediate usage on the program. 
While the first option is the recommended procedure (this way you can avoid parsing and generating the WSDL file each time your
code executes), for simplicity we'll demonstrate the use of the PEAR module with the second option, using the classes on the fly:

{code}
require_once 'SOAP/Client.php';
$requestParams = array ('user'=>'admin', 'pass'=>'asdfasdf');
$wsdl = new SOAP_WSDL('http://localhost:8080/jbilling/services/api?wsdl',
$requestParams);
$client = $wsdl->getProxy();
$userIdParams = array('in0' => $username);
$result = $client->getUserId($userIdParams);
$userId = $result->getUserIdReturn;
$userDataParams = array('in0' => $userId);
$result = $client->getUserWS($userId);
$userData = $result->getUserWSReturn;
{code}

This is quite straightforward, as the PEAR library has done most of the dirty work of parsing the WSDL and setting up the calls. 
The @$requestParams@ is an associative array containing the user name and password for the *j*Billing authentication. Parameters
for the web service calls are passed in associative arrays as well.

If you wish to generate the code for the web service calls for use in the program without having to parse the WSDL every time, 
you can explore how to generate the code and save it to a file with the @$wsdl->generateProxyCode()@ function call of the
SOAP_WSDL object.

h1. An Integration Tutorial

h2. Overview

This section provides an introduction to the use of *j*Billing integration calls. It builds on the 'Trend' tutorial 
found in *j*Billing's *[Getting Started|http://www.jbilling.com/documentation/getting-started-with-jbilling]* guide. 
As such, if you wish to follow the examples in this section, you'll need to follow the *[Getting Started|http://www.jbilling.com/documentation/getting-started-with-jbilling]* Guide
tutorial, creating the Trend entity and adding the Items and Orders. The examples in this section will mainly use the 
+jBilling client API+. If you're unable to use this API (most probably because your system does not make use of the Java 
programming language), you'll need to substitute the API calls with direct SOAP requests. Please, refer to the Integrating *j*Billing to your 
Application chapter, which explains the options for performing service calls to *j*Billing in more detail and provides
examples for some programming languages and SOAP APIs available.

h2. The Trend Website

In the *[Getting Started|http://www.jbilling.com/documentation/getting-started-with-jbilling]* guide, you were introduced to *j*Billing's capabilities by means of a
small tutorial centered around a hypothetical 'Trend' company, which runs a website. Following the tutorial, you were able to create the 
Trend entity, added an Item and created an Order and an Invoice. We'll build on this example, examining how *j*Billing's integration features could be
applied to the Trend website, which needs to integrate with *j*Billing.

h3. Controlling access to the 'Paid' Area of the website

Being a paid service, the Trend website obviously needs to determine whether each user that enters the site is a paying customer 
or not, in order to provide its services only to those that have paid for it. This can be accomplished by the use of the usual user
name/password pair, which will be provided to each customer at the end of the subscription process, once the first payment has cleared.

Of course, the invoicing and payment are handled by *j*Billing, therefore the website needs a way of knowing when the given user-name 
has become a paying customer.

A solution could be to maintain a local record of customers and check each login attempt against it, but this actually represents 
a problem: _how would the program know when a customer has paid or not?_ Without any integration calls, someone would have to keep the
data in this record updated, a manual operation that could introduce errors and takes time.

Another important consideration is that the website charges its customers a monthly fee. This means the status of customers could change 
at any time, if the user, for example, has not paid the fee for the current month (it would fall back to non-paying). A local record of 
customers would not have this information, at least not until the next manual update.

The solution is throwing in an integration call to *j*Billing to ensure the customer at hand has paid his fee and is authorized to access 
the website's resources. *j*Billing takes care of checking its internal data and determines if the client's payment has been processed
and whether his subscription is still valid.

The website's login form retrieves the customer's username and password, performs any local validations and checks the user's status in 
*j*Billing (which will indicate his current payment status and therefore whether he should be authorized to login or not).

The first step (regarding integration calls and not local validation) is therefore to retrieve the *j*Billing's +User ID+ number, and 
request the user's data, so that the current status can be determined. The sequence would be:

{code}
import com.sapienter.jbilling.server.util.api.JbillingAPI;
import com.sapienter.jbilling.server.util.api.JbillingAPIFactory;
import com.sapienter.jbilling.server.user.UserWS;
/*
* We assume the String variable "username" contains the username
* string as entered by the user in the login form.
*/
Integer userId = null;
// Create and initialize the *j*Billing API.
JbillingAPI api = JbillingAPIFactory.getAPI();
boolean canLogin = false;
try {
	userId = api.getUserId(username);
	if (userId == null) {
		/*
		* This shouldn't happen as the API should issue an exception if the
		* user does not exist, but test it anyway. In this case, we simply
		* generate an exception that is catched later in this block
		* of code.
		*/
	}
	// With the user id just retrieved, we can query the user's data.
	UserWS userData = api.getUserWS(userId);
	/*
	* The user data contains many information about the user, but in
	* this case we're mostly interested in the statusId field of the
	* UserWS class.
	* This field values are: 1=active, 2=Overdue 1, 3=Overdue 2,
	* 4=Overdue 3, 5=Suspended 1, 6=Suspended 2, 7=Suspended 3,
	* 8=Deleted. Status Ids from 1 through 4 indicate the user is able
	* to login, all other codes cannot login.
	*/
	int statusId = userData.getStatusId().intValue();
	if (statusId > 0 && statusId <= 4) {
		/*
		* The user can login to the system, as his current status is ok.
		* Just print a notice in case he's late with his last payment.
		*/
		canLogin = true;
		System.out.println("User can log in");
		if (statusId != 1) {
			System.out.println("The user's payment is overdue!");
		}
	}
} catch (Exception e) {
	/*
	* The user does not exist in Jbilling's records. The login request
	* should be denied, and perhaps an error message issued back to the
	* caller. Here, we just print an error message to stdout.
	*/
	canLogin = false;
	System.out.println("Invalid username: the user does not exist!");
}

if (canLogin) {
	// Here you can grant access to the reserved area.
} else {
	// Here you can deny entrance to the reserved area.
}
{code}

{note}
As you can notice from this example, using the *j*Billing API is very straightforward and simple. The burden of setting 
input and output parameters for the call has been hidden in the implementation of the library, and calls seem simpler. 
Take a look at the sample code in the *Integration with non-Java applications* section to see why we strongly recommend this 
approach for Java applications. And, as a bonus, you can easily switch between SOAP calls and Hessian calls with just a change 
in an XML file!
{note}

In the above code:

# We acquire the user's ID with the call to @api.getUserId()@ 
# Use that ID to retrieve the user's account data via call to @api.getUserWS()@ 
# With the user data at hand, we can check if the user's status in *j*Billing warrants his entrance to the paid area. 
  The flag @canLogin@ is set so that we can later determine what response to give to the user.

There's even a simpler way to login into the system: the @authenticate()@ function call requires two String 
arguments (user name and password) and returns a 0 if the user is in a state that allows entrance to the paid area, 
whereas a non-zero response indicates the user does not exist or is in disabled or suspended state. It however does 
not provide information about what specific state the user is in, or if it is overdue or not. 

A quick example using this function would be:

{code}
import com.sapienter.jbilling.server.util.api.JbillingAPI;
import com.sapienter.jbilling.server.util.api.JbillingAPIFactory;
import com.sapienter.jbilling.server.user.UserWS;

// Create and initialize the *j*Billing API.
JbillingAPI api = JbillingAPIFactory.getAPI();
Integer result = api.authenticate(username, password);
if (result.intValue() == 0) {
	// The user is able to loging.
} else {
	// The user cannot login. The return value indicates why.
}
{code}

h3. Trial Period Management

You can easily set up trial accounts so that would-be customers can enter your paid area for free before actually 
being charged. Since a trial period in *j*Billing is managed through a normal order, this will also give a practical 
demonstration of how orders can be entered via the integration calls.

*j*Billing allows you to practice two different trial period policies: _with or without preauthorization_.
Pre-authorized trial periods require the user to enter payment information (usually in the form of credit card data), 
which will be validated before the trial period can begin. Non pre-authorized trial periods do not require this validation phase.

Trial periods are managed by simply delaying the *Active Since* date of the purchase order by a number of days equal to the Trial Period.
Let's say Trend wishes to grant a free 15 day trial period to new customers, so we're going to enter orders with an *Active Since* date of
TODAY + 15. 

This means the login code we just saw will work correctly for trial customers as well. The user appears as _Active_, but the invoicing 
will not take place until the order becomes active. In addition, when pre-authorization is required, you'll need to provide some
payment information, that will be validated before the order insertion ends correctly.

When the trial period ends, the order will become active and *j*Billing will automatically start invoicing the customer. 
If the customer changes his mind and wishes to cancel his membership to the site (either before the trial expires or after actual 
invoicing has taken place), you'll have to provide a cancellation page that will take care of deleting active 
orders, so that no further automatic invoicing takes place. We'll take care of the cancellation code in the next section.

We will need to request all necessary data from the user. Since we will be creating a new user in *j*Billing, we will require the user 
to enter the user name/password pair she intends to use to access the site in the future. This is the minimal information we'll need
to successfully call the user creation service for a non pre-authorized trial, but in production code you would probably need to add 
contact information to the user record, and if you're implementing pre-authorized trials, you'll need to request some payment
information as well. These can be added as parameters to the user creation process.

Once the new user is created, we can add an order to that user with the *Active Since* date set to TODAY + 15, and *Active Until* date 
set to _null_, which indicates the Order is permanently active and will continue to invoice until it is canceled. We are assuming the
Item has been created as indicated in the Getting Started Guide, so that we have a 'Banners' category and a 'Front Page Banner Monthly Fee'
item created under this category. In the example, we assume the Item ID code is '1', in a more realistic situation you could have several 
item types to choose from, or you would otherwise need to determine what the Item ID is from the *j*Billing user interface.

We also assume the periodicity code for the order is '2', which maps to monthly payments. This however depends on the setup of the specific 
instance of *j*Billing, you can determine what specific code each period has by consulting the *[jBilling User Guide|guide:userGuide]* under *Orders -> Periods*.

{note}
The item we're creating an order for is, according to the Getting Started Guide, the fee for displaying a banner in Trend's front-page. 
To keep the example consistent, let's say the login procedure illustrated above allows the customer to login to the area where he can 
upload and update the banner itself, and perhaps see some statistics for his banner's exposure. The code that performs the banner rotation 
would probably need to determine what banners to show (maybe a local database, which of course needs to be kept in sync with billing data, 
something we'll cover in another section). 
{note}

{code}
/*
 * We assume the String variables "username" and "password" contain the
 * new user's login data as entered by the user in the trial registration form.
 */
Integer userId = null;
// Create and initialize the *j*Billing API.
JbillingAPI api = JbillingAPIFactory.getAPI();
try {
    // Create the user's record.
    UserWS newUser = new UserWS();
    // Fill in the new user's data.
    newUser.setMainRoleId(new Integer(5)); // Role "5" = "Customer".
    newUser.setStatusId(new Integer(1)); // Status "1" = "Active".
    newUser.setUserName(username);
    newUser.setPassword(password);
    // Refer to Appendix A for language codes.
    newUser.setLanguageId(new Integer(1));
    // Refer to Appendix A for currency codes.
    newUser.setCurrencyId(new Integer(1));
    newUser.setCreateDatetime(new java.util.Date()); // = now
    // If you're entering credit card information, you'll need to create
    // a CreditCardDTO object and fill it with data, and assign the data
    // to this user via the setCreditCard() method of UserWS. Same goes for
    // Contact info, a ContactDTO object can be assigned via setContact().
    // Call the "create" method on the api to create the user.
    Integer newUserId = api.createUser(newUser);
    // Now let's create a new order line.
    OrderLineWS line = new OrderLineWS();
    line.setPrice(new BigDecimal(10)); // Order price = 10.
    line.setTypeId(new Integer(1)); // Type 1 = "Item".
    line.setQuantity(new Integer(1)); // Quantity = 1
    line.setAmount(new BigDecimal(10)); // Total amount = 10
    line.setDescription("Banner on Front Page");
    line.setItemId(new Integer(1));
    // Now create an order that contains the order line just created.
    OrderWS newOrder = new OrderWS();
    newOrder.setUserId(newUserId);
    newOrder.setPeriod(new Integer(1));
    // Now add the order line created above to this order.
    newOrder.setOrderLines(new OrderLineWS[] { line });
    newOrder.setBillingTypeId(new Integer(1)); // Prepaid order.
    GregorianCalendar activeSinceDate = new GregorianCalendar();
    activeSinceDate.add(Calendar.DATE, 15);
    newOrder.setActiveSince(activeSinceDate.getTime());
    // Now create the order.
    Integer newOrderId = api.createOrder(newOrder);
} catch (Exception e) {
    /*
     * There was an error during the user or order creation. Just print an
     * error message.
     */
    System.out.println("Error in user or order creation");
}
{code}

A few IMPORTANT details need to be pointed out: first, we create the user and order in two separate steps, 
since we wanted to show how both operations worked on their own, but the API provides a way of doing both operations 
in one step. Instead of calling @api.createUser(newUser)@ and @api.createOrder(newOrder)@, you can just call 
@api.create(newUser, newOrder)@. 

This call will also charge the user credit card, but not as a pre-authorization, but as a full charge (capture). 
The method 'create' does four steps:

# Creation of the user
# Creation of the purchase order
# Generation of an invoice based on this purchase order
# Processing of the payment to get the invoiced paid.

In the example, we only got the first two steps, which is consistent with the requirements of a free trial: 
the invoice and payment should only happen when the trial is over and the 'active since' of the order reached. If you do the 
single-step 'create' call, be sure to set the User ID of the new order to '-1', since you're creating the user at the same time
you're adding the order and therefore the correct User ID is not yet known.

If you wish to do pre-authorization, you'll need to fill credit card information and add it to the new user data. Then, for 
the second step (order creation) you should call

{code}
api.createOrderPreAuthorize(newOrder)
{code}

, instead of calling the @createOrder()@ method. Note that in this case you cannot use
the @create(newUser, newOrder)@ method indicated above, as it does not do pre-authorization. Therefore, you'll need to perform 
the two separate steps. The @createOrderPreAuthorize()@ method  returns a @PaymentAuthorizationDTOEx@ structure, which provides info on the
authorization released. At this point, you're probably most interested in knowing if it was successful, so just test the 
boolean result by calling getResult(). The following snippet shows how:

{code}
PaymentAuthorizationDTOEx payment = api.createOrderPreAuthorize(newOrder);
if (payment.getResult() == false) {
	System.out.println("Your payment was not accepted! Trial not active!");
	// Since the user has been already created, you might want to delete it
}
{code}

Keep in mind that if you create the user and the trial order in two separate steps, and so you could have a situation in which the user 
gets created but the Order could not be submitted. So, if the code catches an exception, test if the user exists (For example, if you received a User ID
from the first call that is non-null) to intercept such a situation.

Finally, this does not test whether the user existed previously with that user name. When creating a user, you can first validate if the user exists, 
by querying its User ID, as done in the login section above, and display an error or request a different user name. It also
does not verify whether the user has already created other trial accounts.

To intercept situations in which a user creates trial accounts just to cancel them before billing takes place to create another 
trial account, ask for some contact information (such as, for example, a valid e-mail address or just save the IP address of the caller) 
and verify that this information is not repeated in previous trial accounts.

h3. Contact Information

The users data structure contains fields to keep Contact information along with your *j*Billing's user account. Adding or updating contact 
data is quite simple: you just add it to the user's data structure whenever you call @createUser()@ or @updateUser()@. There's a shortcut 
call that allows you to edit contact information as well:

{code}
updateUserContact()
{code}

To add contact information to an account, create the @ContactWS@ instance and fill it as necessary. Most data fields in this structure 
are self-explanatory, such as _postalCode_ or _faxNumber_. For example, the following code snippet creates a @ContactWS@ structure and puts 
some data into it, and later it passes it to the user creation process:

{code}
// Create the ContactWS structure
ContactWS contactInfo = new ContactWS();
// Put some data into it
contactInfo.setPostalCode("12345");
contactInfo.setFaxNumber("555-123456");
contactInfo.setEmail("foo@bar.com");
// Pass the contact info to the user creation call
// This assumes userData is an already filled UserWS structure.
userData.setContact(contactInfo);
// Now create the user
api.createUser(userData);
{code}

Here, we pass the contact information in the user creation process, but you could as well pass this information in an @updateUser()@ call 
when updating user data, or in a separate call to @updateUserContact()@ if you wish to only update contact information and leave the 
user data as it is.

h4. Custom Contact Fields

The User's Contact Information is extensible for adding additional user Contact information. Thus, two fields of the @ContactWS@ structure 
deserve further understanding: _fieldNames_ and _fieldValues_., which represent custom contact data. 
For example, let's say you need to store the user's website address. A quick look at the @ContactWS@ structure shows there's no website 
field, so you would be left with the option of storing that info in another field not currently used, but *j*Billing offers a better alternative: 
*Custom Contact Fields (CCF)*.

To use CCF you will need to add it to the system through some configuration. This is covered in another document, but it boils down to two 
simple steps:

# add the field to the the contact_field_type table:

{code}
insert into contact_field_type (id, entity_id, prompt_key, data_type, customer_readonly) values (432, 1, 'ccf.web_site', 'string', 1);
{code}

# add the name of the field to the file ApplicationResources.properties:

{code}
ccf.web_site=Web site URL
{code}

Customizing your contact info is quite straightforward: you need to provide two arrays of strings. The first array, @fieldNames@, 
contains the IDs for each of the CCFs that you wish to specify a value for. The second array, @fieldValues@, holds the actual values 
for the fields. When entering custom contact data, you need to initialize both arrays with data and add them to the 
@ContactWS@ structure. A quick example explains how:

{code}
// The CCF id to set is 432, following the above example
public static final String CCF_WEBSITE = "432";

// Now we create two string arrays for the Ids and values.
String customContactIds[] = new String[1];
String customContactValues[] = new String[1];

// Put the values into the arrays.
// this holds the unique ID for the field.
customContactIds[0] = CONTACT_WEBSITE;
// this holds the actual value.
CustomContactValues[0] = "www.fifa.com";

// Set the custom fields in the ContactWS structure.
// We assume contactData is an already created and filled ContactWS structure.
contactData.setFieldNames(customContactIds);
contactData.setFieldValues(customContactValues);

// We now proceed with the contact data creation process.
{code}

We defined a constant that holds a unique identifier for the custom contact fields. It will have to be equal to the ID 
of the row in the contact_field_type table that defines this field. In this case, ID 432 will contain website information. 
Of course, this constant would ideally be located in a separate class or externalized to a properties file, to keep things 
simple we just declared it on the fly. We then create two String arrays (each containing just one element) and assign the ID
number and field value, respectively. We then assign these arrays to the _fieldNames_ and _fieldValues_ fields in the @ContactWS@ structure. 
When the api call is performed, the custom data will be saved along with the rest of the contact data. 
A fixed length array is of course not very intuitive, but you can easily convert these two arrays into a [HashTable|api:java.util.Hashtable] and use the 
ID value as an index to the actual data.

h3. Updating and Deleting Users and Orders

There are many situations in which you would need to update the user's information, such as for example when the user changes passwords or address. 
It is also common that the user subscribes to a service, or cancels a subscription. These type of events are reflected through purchase orders 
in *j*Billing, you will need a way to update orders programmatically. This section provides some insight into these operations.

Updating a user or order is easy enough. You just need to *query its current data, change the fields you need to update, and call the proper update 
method*. For example, let's say a user changes his password, the sequence to perform would be:

{code}
// Get the user information from *j*Billing
UserWS userData = api.getUserWS(userId);

// Change the password in the user data and submit it back to the system.
userData.setPassword(newPassword);
api.updateUser(userData);
{code}

Here we assume you already have the User ID handy after the used logged in, perhaps as a session variable.

There are similar functions to update orders (updateOrder), order lines (updateOrderLine), credit card information (updateCreditCard) 
and contact information (updateUserContact). They are used much in the same manner. You can of course populate the UserWS data from scratch, 
instead of querying it from *j*Billing, if you have all the necessary information handy. You can also delete an user or order, if necessary. 
The methods are, as you have probably guessed, deleteUser and deleteOrder. You need only the User ID or Order ID to perform the deletion, 
not the entire UserWS or OrderWS structures. For example:

{code}
api.deleteUser(oldUser);
{code}

This will delete the user. Keep in mind that *j*Billing does not actually delete the user from the database, it just marks it as deleted. 
Of course, when a user gets deleted, so does the contact and credit card information that was associated to the account, and orders 
are deactivated (they will be no longer invoiced). Deleting an order deletes the order lines associated with it, as well. When you query the
status for a user that has been deleted (for example, in the login page), you'll get the 'Deleted' status code as response.

h4. The user's _main_ order

*j*Billing introduces the concept of a main order for each user. This simply tells *j*Billing which order should be the target when executing automated 
operations such as recurring charges. *[jBilling User Guide|guide:userGuide]* covers this concept in greater detail, here we're mainly interested 
in how the user's main order can be specified or modified by means of API calls.

The main order of a user can be found on the [UserWS|api:com.sapienter.jbilling.server.user.UserWS] structure (returned by @getUserWS()@), in field _mainOrderId_ (which contains the unique identifier of the order
that acts as main order for this user). So, it is easy to access it with user API calls:

{code}

// Get the user information from *j*Billing
UserWS userData = api.getUserWS(userId);

// Read the main order ID into a variable and set
// another order (retrieved previously) as main.
Integer mainOrder = userData.getMainOrderId();
userData.setMainOrderId(newMainOrder);
api.updateUser(userData);

{code}

It is also possible to determine if an Order is the current *main order* by examining the Order's record (there's a property named _isCurrent_ that indicates whether 
the order is the main order or not). When creating a new order, you can also set this property to '1' to tell *j*Billing that the order being created is to be considered 
the main order for its user:

{code}

OrderWS newOrder = new OrderWS();

// Set order parameters here ...
newOrder.setIsCurrent(Integer.valueOf(1));

// Create the order:
api.createOrder(newOrder);

{code}

h3. A word on Pricing

Pricing is the process that performs calculations to the Order data to find the correct price for the order. While possibly an *Quantity * Price per Item* scenario is sufficient, 
many companies have a much more complicated process to calculate prices. For example, you can apply a Discount for large Orders, or have preferential rates for select 
Customers and/or Items.

*j*Billing solves this problem by providing a business rule-based mechanism for price formation. While the inner workings of the Business Rules Engine lies outside the scope of
this document (please refer to the [Extension Guide|3. Extension Guide] for details on how to integrate Drools-based rules into *j*Billing), let's briefly describe how to 
interact with this component, and use it in your integration calls.

Pricing is usually based on the characteristics of the item (For Example, 'Apply a 15% discount on Item A if quantity of Item is above 15') or order ('Apply a 10% discount to
any orders entered by User B'). There are situations, however, when the Order or Item data is not sufficient to describe the formation of price. 

For example, consider a situation in which we have created a 'click on a banner' Item (as exemplified in the Trend example of the *[Getting Started|http://www.jbilling.com/documentation/getting-started-with-jbilling]* guide) with ItemID = 2. 
We need to apply different prices depending on the country of origin of the customers who clicks on the banner. Without a rule-based pricing system, the only solution is 
to create as many items as there are countries, and charge the right item when the server has decoded the country of origin of the visitor, which is certainly not a good 
solution. Therefore, by using rule-based pricing, we can create one single Item and tailor the price this Item will have according to external conditions.

To address these situations, *j*Billing introduces the concept of *'pricing fields'*. A Pricing Field is simply a value that is passed verbatim to the pricing engine, to be used 
if required during the price formation phase.

The pricing fields are useful in our example because the country of origin is known only by the server that is creating the order on *j*Billing, and only after the event has taken
place. So, the only way we can specify variable data that alters the way rules behave at runtime is passing these values to the rule engine for evaluation.

Now, lets code the rules that set different prices for our *'click on a banner'* Item according to the country of origin. To keep things simple, we're assuming here that 
the server that originates the call to *j*Billing passes the country as a string containing the ISO code of the country of origin.

{code}

rule 'pricing rule for the US'
when
	exists(PricingField( name == "countryFrom", strValue == "US" ))
	$line : OrderLineDTO( itemId == 2 ) #the 'click on a banner' item
then
	$line.setPrice(10.0F); # price for US customers is 10$.
end

rule 'pricing rule for Canada'
when
	exists(PricingField( name == "countryFrom", strValue == "CA" ))
	$line : OrderLineDTO( itemId = 2 )
then
	$line.setPrice(9.0F); # price for canadian customers is 9$.
end

{code}

The above rule can be read as: "apply a price of 10$ to order lines with Item 2 for users connecting from the US, and 9$ for order lines with Item 2 for users connecting from
Canada". We can now code the API client that passes customer country in a new PricingField variable with name "countryFrom":

{code}

JbillingAPI api = JbillingAPIFactory.getAPI();
String country = "US"; // your application code determines the origin
PricingField pf = new PricingField("countryFrom", country);
PricingField[] pfields = new PricingField[] { pf };
OrderWS order = new OrderWS();

// Initialize order parameters here...
order.setPricingFields(PricingField.setPricingFieldsValue(pfields));

// now, let's rate the order
OrderWS result = api.rateOrder(order);

{code}

This sample code creates a pricing field containing "countryFrom" = "US", so, if run, all order lines containing Item 2 are assigned a price of 10$ in the output OrderWS
structure.	

{note}

A PricingField can hold one of a String, Date, Integer or Double value, a name that identifies the PricingField (and can be used as 
demonstrated above). For more details, see the PricingField structure definition below.

{note}

If you examine the structure of the @OrderWS@ class, you'll see that its pricing fields are contained in a String, for serialization 
purposes. To simplify access to this data, the @PricingField@ class offers utility methods to decode the serialized string into an array of
@PricingField@ values and encode an array of @PricingField@ classes into a string. This of course can only be done if you're using the API, 
SOAP clients should encode the string by hand.

Encoding is actually very simple, pricing fields are separated by commas, and each element of the pricing field is separated from the 
others by colons, in the following order: *"name:position:type:value"* (name is a string value corresponding to the name of the
pricing field, position is an integer indicating the ordering of pricing rules, type is one of "string", "integer", "double" or "date", and 
value has the string formatted value for the field). Correct examples of encoded strings are: *"countryFrom:1:string:US"* or *"newPrice:1:double:5.5,oldPrice:1:double:6.0"* 
(the second example has two pricing fields encoded, notice the comma separating each element).

In this manner, it is possible to quickly add pricing rules that do not apply to specific Items or Orders, but are rather applied based on 
external events (that translate to appropriate @PricingField@ values) or other constraints not directly determined from the Order or Item data structures.

h3. Keeping *j*Billing in sync with your data

While you can place many service calls to *j*Billing and expect it to update its information directly, there are times in which asynchronous events take place in 
either your system or in *j*Billing that change the data in one way or the other. For example, a scheduled payment could have been rejected by the processor, or 
new invoices have been generated in a specific date, or users could change their status due to payment events (they become overdue or suspended, etc.).

When it is your data that changes, it could be a simple matter of calling the appropriate update methods in the Client API to sync *j*Billing to your changes. 
When it is *j*Billing that changes its data, you'll need to resort to specific API calls or setup *callback* functions.

The Client API provides several query functions that can be used to update your data. Most of these functions have the "get" prefix. For example, if you keep 
a list of all users and their current status in your system, you could simply fire up an update job every night or so and call the getUserWS() method for 
each user in the list to update their data. This, however, is both time- and resource-consuming. It will work for small volumes of data, but it will not scale up.

Some API query methods return sets of results and not just the data that corresponds to one element. The @getUsersInStatus()@ function returns a list of 
the User IDs of all users that are in a specific status, for example, @getUserInStatus(new Integer(1))@ returns all users that are currently active. 
As another example, @getOrderByPeriod()@ returns a list of all orders that have the same periodicity (in our previous example, @getOrderByPeriod(new Integer(2))@ 
returns all orders that recur monthly).

h4. Subscription Status

The [UserWS|api:com.sapienter.jbilling.server.user.UserWS] structure maintains a field named _subscriberStatusId_ which contains the status code for subscribers. 
This status field is kept updated internally by *j*Billing to reflect the overall status of a user as a subscriber. Event such as a failed payment, or a
successful payment, produce changes to this status. It is easy to retrieve the current user's status by calling @getUserWS()@. Another important query method 
is @getUserTransitions()@. This method returns a list of all users that underwent a transition in their Subscription Status in a given time period. You can call 
this method periodically (daily, for example), to keep your application updated with who is subscribed and who is not to your services. The method receives a pair 
of date values as arguments, indicating the starting and ending date of the period where transitions occurred. You can assign a null value to
either or both of these parameters. The query remembers the last time you called it, so if you specify a null starting date, it will extract all transitions made 
from the moment you last called this function. 

If the ending date is null, there's no upper limit to the transition dates (i.e., the upper limit is the current date). The query returns a set of [UserTransitionResponseWS|api:com.sapienter.jbilling.server.user.UserTransitionResponseWS] 
structures that contains all transitions of subscription status registered in the given period of time.

h4. Setting up Call Backs

As seen, the API provides a rich set of queries that allow your program to determine the status and information about most of the events your 
program needs to be informed about. You can therefore use these calls to update your program's data from *j*Billing, by creating recurring tasks 
that periodically query your *j*Billing installation and update your data accordingly.

Some situations, however, warrant a finer degree of control. User status changes are the most hard to manage with API calls, since they occur 
in a rather asynchronous manner, and checking the status for all your users could prove a resource hog. Also, you would ideally need to know 
of the change quickly, so that you can suspend services to a user that has not paid your invoices.

{note}
Note that, although related, the 'ageing status' is not the same as the 'subscription status'. The first one is related to the ageing
process, while the second is not, it is only affected by recurring orders and payments. Call backs are only done for changes in the 'ageing status'.
{note}

Ideally, you would need a way to receive a notification when a user status changes, so that you proceed to update only the user that has been affected 
by the change. This is where the HTTP Call Back (*HCB*) interface comes to the rescue.

The HBC feature of *j*Billing is capable of performing a web call to your application whenever a user status changes. HBC will notify your application what 
user incurred in the change, the old and new status, the user's login name, and whether the new status allows the user to login or not. This information 
can come handy to update your data on the fly.

HBC performs a normal web request, passing the information about the status change to your application via POST parameters. So, your application
needs to publish a web page that takes care of receiving the notification, get the parameters from the request form and act accordingly.

{note}
The drawback of this method is that, if the page that listens to the call backs is not responding, the call will fail and your application will 
be outof-sync.
{note}

Setting up HBC requires you to enter *j*Billing's User Interface as an administrator, and set the callback URL in the "Ageing" screen. 
When a valid URL is placed in this field, *j*Billing will POST a request to that URL whenever a user changes status. This callback can 
be redirected to a task in your program that registers the status change in your data structures.

The POST callback performed by *j*Billing provides the called routine with the following information pertaining the event that has occurred:

* @cmd@ - A string that identifies *j*Billing's call. It is always set to "ageing_update" by *j*Billing, and allows you to uniquely identify a 
*j*Billing call (in case the callback's url is used for other purposes)

* @user_id@ - The User ID of the user that is undergoing a status change in *j*Billing. You can use this ID to identify the user directly, 
or otherwise query *j*Billing via the API to obtain the data for the user, should you need further information

* @login_name@ - The user name of the user that is undergoing a status change

* @from_status@ - The status the user is transitioning from. This is the status the user had before the transition took place

* @to_status@ - The status the user is transitioning to. This is the status the user has once the transition took place. Subsequent calls 
to @getUser()@ in the API will return this status code

* @can_login@ - Indicates whether the user's new status allows him to have access to the website's member's area or not. 
A value of "1" indicates the user can login to your system, a "0" means he cannot. This information can be safely ignored, if you check the
user's status during the login phase, as explained in a previous chapter

A quick example of a callback routine handler is given below. This routine simply prints a status change notice to the console, 
but ideally your application would use this data in a more useful manner. This code constitutes the @doPost()@ method of a Java servlet
class that services the callback inside your application:

{code}
public void doPost(HttpServletRequest request, HttpServletResponse resp)
throws ServletException, IOException {
    // The doPost() method of the servlet class. This services all callbacks
    // from *j*Billing into your app.
    String userName;
    Integer userId;
    Integer fromStatus;
    Integer toStatus;
    boolean update = false;
    // Test whether this is a *j*Billing call by checking the "cmd" parameter.
    if (request.getParameter("cmd").equals("ageing_update")) {
        userName = request.getParameter("login_name");
        try {
            userId = new Integer(request.getParameter("user_id"));
            fromStatus = new Integer(request.getParameter("from_status");
            toStatus = new Integer(request.getParameter("to_status");
        } catch (NumberFormatException e) {
            // If the values passed were not numbers do not
            // perform the update.
            update = false;
        }
        if (update) {
            // Here we just print out a notice. Your app should
            // do something more sensible, such as updating your data.
            System.out.println("User " + userName + " has changed status!");
        }
    }
    else {
        // This was not a *j*Billing call. You can process it normally
        // or return an error, as needed.
    }
}
{code}

h2. Conclusion

This document provided a hands on guide to using *j*Billing's integration services. While
the Client API provides much more service calls and features than what was covered
here, we hope this tutorial has provided some useful insight into how to put the
integration API to good use in your programs.
The sections that follow cover all service calls and data structures provided by the Client
API in more depth, and explain what parameters they require and what information you
get in return, where applicable. Please refer to these sections for further details.
The *j*Billing integration layer provides a rich set of features that allow your application to
seamlessly integrate the billing process into your business logic. The Client API provides
a flexible and intuitive layer of abstraction that further simplifies the integration process
and makes your application independent of the specific technology that takes care of
communicating with the *j*Billing server. The Client API is easily available to any Java
application.
The SOAP layer provides further support for non-Java applications that nevertheless
need to integrate with *j*Billing. Most modern web programming frameworks provide
support for SOAP services, which greatly expands the set of programming languages
and production environments that *j*Billing can integrate with.

h1. Client API Reference

h2. Data Structures/Object Classes

h3. User Management

h4. UserWS

{table}
 *Property name*|*Type*|*Description*
 ach | AchDTO | ACH Payment details saved for the User. If available, the ACH info can be used during Automatic Payment processing. 
 autoRecharge | String | Amount by which the customer's account will be auto-recharged when depleted (the amount can be handled as a BigDecimal Java type via the "setAutoRechargeAsDecimal()" and "getAutoRechargeAsDecimal()" methods. The system should be configured to use Auto-Recharge feature. 
 automaticPaymentType | Integer | Integer value to determine which of the three payment methods does the customer want to apply for automatic payment processing. Refer to Appendix A for acceptable values. 
 balanceType | Integer | The type of dynamic balance for this user. Refer to Appendix A for acceptable values. 
 blacklistMatches |  String[] | Lists any blacklist matches for this user. See the "jBilling User Guide" for more information on blacklists. 
 childIds |  Integer[] | The identifiers of any sub-accounts for this user. 
 companyName | String | User's company name. 
 contact | ContactWS | The primary contact information for this user. 
 createDatetime | Date | Creation date of this data record. 
 creditCard | CreditCardDTO | Credit card information for this user. Not required for the user creation process. 
 creditLimit | Double | The credit limit. Only valid if balanceType is of credit limit type. 
 currencyId | Integer | Contains the currency code for this user. Refer to Appendix A for acceptable values. 
 customerId | Integer | Reference to the Customer information for this user. 
 deleted | Integer | If the record has been deleted, this field contains '1', otherwise it contains '0'. Note that deletion cannot be carried out by simply setting a "1" in this field. 
 dueDateUnitId | Integer | Period Unit of this Customer's Invoice due date. Refer to Appendix A for Period Unit acceptable values. 
 dueDateValue | Integer | Customer specific Invoice Due date value 
 dynamicBalance | String | String representation of this Customer's dynamic balance. The dynamic balance. If balanceType is credit limit, this represents the amount of credit used on the account. If balanceType is pre paid, this represents the pre paid balance remaining. 
 excludeAgeing | Boolean | Boolean value to indicate excluding this User/Customer from the Ageing process 
 failedAttempts | Integer | Number of login attempts that have been failed by this user (i.e., the user has entered the wrong password). 
 invoiceChild | Boolean | "true" if this is a sub-account (child of a parent account), but this user will still receive invoices. 
 invoiceDeliveryMethodId | Integer | Reference ID for one of the Invoice Delivery Methods. See appendix for acceptable values. 
 isParent | Boolean | "true" if this record is a "parent" user. A parent user can have sub-accounts (children). 
 language | String | Name of the language (i.e. "English"). 
 languageId | Integer | Contains the preferred language code for this user. Refer to Appendix A for acceptable values. 
 lastLogin | Date | Date of the last login performed by this user.  
 lastStatusChange | Date | Date of the last status change incurred by this user. 
 mainOrderId | Integer | The id of the main order for this customer. This is the order that sets the customer's billing cycle for the management of 'current' orders'. Current orders gather usage. See section: The user's "main" order for a description and examples of use of main orders. You can set this value to an order and call 'updateUser' to set a new order as the main order. 
 mainRoleId | Integer | The level of privilege granted to the user when logged into the system. See Appendix A for acceptable values. 
 nextInvoiceDate | Date | The earliest next billable date for this user's Orders. 
 notes | String | CRM notes for this user. 
 owingBalance | BigDecimal | A real-time calculated owing balance. (All Invoices - All Payments) 
 parentId | Integer | If the user belongs to a parent record, this field contains the identifier of the parent record. 
 partnerId | Integer | Identifier of the partner this user belongs to. 
 password | String | Authenticates the user's identity during login. This could be meaningless if the password is encrypted. 
 role | String | The name of the User's role (i.e. "Clerk" or "Customer"). 
 status | String | Name of the User's current status (i.e. "Suspended" or "Active"). 
 statusId | Integer | Current status identifier of the user. See Appendix A for acceptable values. 
 subscriberStatusId | Integer | Subscriber status for this user. See Appendix A for acceptable values. 
 userIdBlacklisted | Boolean | *true* if the user id is blacklisted. See the *jBilling User Guide* for more information on blacklists. 
 userName | String | Identifies the user during login. 
{table}

h4. CreditCardDTO

{table}
 *Property name*|*Type*|*Description*
 deleted | Integer | If the record has been deleted, this field contains "1", otherwise it contains "0". Note that deletion cannot be carried out by simply setting a "1" in this field. 
 expiry|Date| Expiration date of the credit card. Usually, card expiration dates are expressed in month/year form, such as "05/11" or "May 2011". This field contains the last day the card is valid, in this example, "05/31/2011". 
 id|Integer|Unique identifier for this record. 
 name|String|Credit card owner's name. This is the name that appears physically on the credit card. 
 number|String|Credit card number. Usually, a 16 digit number. 
 securityCode|Integer|CCV (Credit Card Verification) code of the credit card. 
 type|Integer|Credit Card type. See Appendix A for acceptable values. 
{table}

h4. ContactWS

{table}
 *Property name*|*Type*|*Description*
 address1|String|First line for the address. 
 address2|String|Second line for the address. 
 city|String|City of this contact. 
 contactTypeDescr|String|Description of the contact type of this contact namely 'Primary' 
 contactTypeId|Integer|Identifier for the type id of the Contact i.e. id of contact_type table. A contact has atleast one 'Primary' contact type and may have more Contact Types. 
 countryCode|String|Country code for this contact (Appendix A contains a list of acceptable country codes). 
 createDate|Date|Date this contact record was first created. 
 deleted|Integer|If the record has been deleted, this field contains "1", otherwise it contains "0". Note that deletion cannot be carried out by simply setting a "1" in this field. 
 email|String|Email address of this contact. 
 faxAreaCode|Integer|Area Code for the fax number, if any. 
 faxCountryCode|Integer|Country Code for the fax number, if any. 
 faxNumber|String|Fax number. 
 fieldIDs|Integer[]|Database table primary keys or ids of contact_field_type table. Used to identify Custom Contact Field types 
 fieldNames|String[]|The name of each of the customized contact fields contained in this contact record. 
 fieldValues|String[]|The values for each of the customized contact fields contained in this contact record. 
 firstName|String|First name of this contact. 
 id|Integer|Unique identifier of this contact. 
 include|Integer|*1* if this contact is marked as included in notifications. 
 initial|String|Middle name initials, if any. 
 lastName|String|Last name of this Contact. 
 organizationName|String|Name of the organization the contact belongs to. 
 phoneAreaCode|Integer|Phone number Area Code. 
 phoneCountryCode|Integer|Phone number Country Code. 
 phoneNumber|String|Phone number. 
 postalCode|String|ZIP Code for the contact's address. 
 stateProvince|String|State or Province of the contact's address. 
 title|String|Title for the contact, such as "Mr." or "Dr.". 
{table}

h4. UserTransitionResponseWS

{table}
 *Property name*|*Type*|*Description*
 fromStatusId| Integer |Status of the subscription before the transition took place. See Appendix A for acceptable values. 
 id|Integer|Unique identifier for the transition record. 
 toStatusId|Integer|Status of the subscription after the transition took place. 
 transitionDate|Date|Date and time the transition took place. 
 userId|Integer|Identifies the user account that suffered the subscription status change. 
{table}

h3. Order Management Calls

Useful for entering Orders and querying information about Orders.

h4. OrderWS

{table}
 *Property name*|*Type*|*Description*
 activeSince|Date|The point in time when this order will start being active, reflecting when the customer will be invoiced for the items included. A null value indicates that the order was active at creation time (see field createDate). 
 activeUntil|Date|The point in time when this order stops being active. After this date, the order will stop generating new invoices, indicating that the services included in this order should stop being delivered to the customer. A null value would specify an open-ended order. Such order never expires; it is considered on-going and will require explicit cancellation for it to stop generating invoices. 
 anticipatePeriods|Integer|How many periods in advance the order should invoice for. Leave with a '0' unless you have configured the system to work with anticipated periods. 
 billingTypeId|Integer|Indicates if this order is to be paid for before or after the service is provided. Pre-paid orders are invoiced in advance to the customer, while post-paid are only invoiced once the goods or services included in the order have been delivered. "1" means "pre-paid", while "2" means "post-paid". 
 billingTypeStr|String|(Read only). The word that represents the billing type. It is ignored when you submit the object. 
 createDate|Date|(Read only). A time stamp with the date and time when this order was originally created. 
 createdBy|Integer|The id of the user that has created this order. 
 currencyId|Integer|Currency code. Refer to Appendix A for a list of acceptable values. 
 cycleStarts|Date|The date at which the billable cycle starts. A recurring order will generate invoices at the day of the month specified in this field. The date provided in this field must comply with the following condition:		cycleStarts = createDate  For example, for an order created on 01/13/2009, setting this field to 01/28/2009 will make the system generate the invoices the 28th of each month (for orders with monthly periodicity). If set to null, the system will calculate the appropriate billing date based on the date of creation of the order and its activity period. 
 deleted|Integer|A flag that indicates if this record is logically deleted in the database. This allows for 'undo' of deletions. Valid values are 0  the record is not deleted 1  the record is considered deleted. 
 dfFm|Integer|Only used for specific Italian business rules. 
 dueDateUnitId|Integer|If this order has a specified due date, this will the the units (days, months, years). See Appendix A for valid values. 
 dueDateValue|Integer|How many units will be used for the due date. 
 generatedInvoices|InvoiceWS[]|An array of InvoiceWS objects for all the invoices generated till the time for this Order. 
 id|Integer|A unique number that identifies this record. 
 isCurrent|Integer|A flag that indicates whether this order is the current main subscription. See section: The user's "main" order for a description and examples of usage of this field.  <p>Acceptable values are:</P><p>0  The order is not the current main order.</p><p>1  The order is the current main order. 
 lastNotified|Date|When the order has expiration notification, this field tells when the last one was sent. 
 nextBillableDay|Date|The date when this order should generate a new invoice. Meaning that until that date (and excluding that date), the customer has been invoiced for the service included in this order. 
 notes|String|A free text field for any notes for this Order. 
 notesInInvoice|Integer|"1" if this order's notes will be included in the invoice, or "0" if not. 
 notificationStep|Integer|What step has been completed in the order notifications. 
 notify|Integer|A flag to indicate if this order will generate notification as the 'active since' date approaches. 
 orderLines|OrderLineWS[]|The order lines belonging to this order. These objects will specify the items included in this order with their prices and quantities. See the OrderLineWS specification for more information. 
 ownInvoice|Integer|A flag to indicate if this order should generate an invoice on its own. The default behavior is that many orders can generate one invoice. 
 period|Integer|Indicates the periodicity of this order. In other words, how often this order will generate an invoice. Examples of periods are: one time, monthly, weekly, etc. Period codes can be seen in jBilling's User Interface under "Orders -> Periods". 
 periodStr|String|(read only). The description of the order period. 
 pricingFields|String|An array of pricing fields encoded as a String. To encode, use the PricingField.setPricingFieldsValue() static method, which takes as parameter an array of PricingField structures and returns the encoded string. To decode, use the PricingField.getPricingFieldsValue() static method, which takes as parameter an encoded string and returns an array of PricingField structures. Pricing fields are descriptors that provide further information to the pricing engine and aid in forming the price for the order itself. See section "A word on pricing" for a more detailed explanation of the use of pricing fields. 
 statusId|Integer|An order has to be on status 'Active' in order to generate invoices. An order usually starts in active status, and only goes to suspended or finished when the customer fails to make the required payments. The steps and actions taken due to late payments are part of the ageing process. See Appendix A for a list of acceptable order status codes. 
 statusStr|String|(Read only) The description of the current order status. 
 timeUnitStr|String|(Read only) The description of the time unit used for billable periods. 
 total|String|(Read only) A string representation of the BigDecimal value of sum-total of all the order lines of this order, in other words, total order amount. 
 userId|Integer|An identifier for the User to whome thiis order belongs. 
{table}

h4. OrderLineWS

{table}
 *Property name*|*Type*|*Description*
 amount|BigDecimal|The total amount of this line. Usually, this field should equal to the product of price * quantity. This amount will be the one added to calculate the purchase order total. The currency of this field is the one specified in its parent order. The amount can be also set and obtained as a Java BigDecimal, using the "getAmountAsDecimal()" and "setAmountAsDecimal()" methods. 
 createDatetime|Date|A time stamp applied when this record is created. 
 deleted|Integer|A flag that indicates if this record is logically deleted in the database. This allows for 'undo' of deletions. Valid values are 0  the record is not deleted 1  the record is considered deleted. 
 description|String|A descriptive text for the services being included. This usually copies the description of the item related to this line. 
 editable|Boolean|Indicates whether this order line is editable or not (i.e., it cannot be submitted for update). 
 id|Integer|A unique number that identifies this record. 
 itemDto|ItemDTOEx|Contains information of the item this order line refers to. 
 itemId|Integer|The id of the item associated with this line, or null if this line is not directly related to an item. It is consider a good practice to have all order lines related to an item. This allows for better reporting. 
 orderId|Integer|Identifier of the order that contains this order line. 
 price|String|The price of one item, or null if there is no related item. Can also be manipulated as a Java BigDecimal using the "getPriceAsDecimal()" and "setPriceAsDecimal()" methods. 
 priceStr|String|The price of the item as a string. 
 provisioningRequestId|String|The provisioning request UUID for this order line, if it exists. 
 provisioningStatusId|Integer|The provisioning status id for this order line. See Appendix A for valid values. 
 quantity|String|The quantity of the items included in the line, or null, if a quantity doesn't apply. It can also be handled using the "getQuantityAsDecimal()" and "setQuantityAsDecimal()" methods. 
 typeId|Integer|An order line usually has items. However, some lines are used for additional charges, like taxes. See Appendix A for a list of acceptable order line type codes. 
 useItem|Boolean|If true, when submitted, this line will take the price and description from the item. This means that you would not need to give a price and description for the line. Instead, you only provide the id of the item. See the createOrder section for details. 
{table}

h4. CreateResponseWS

{table}
 *Property name*|*Type*|*Description*
 invoiceId |Integer  |  Identifier of the invoice that was generated. 
 orderId|Integer|Identifier of the order that was created. 
 paymentId|Integer|Identifier of the payment that was generated to pay the invoice. 
 paymentResult|PaymentAuthorizationDTOEx|Payment Result data structure with the outcome details of the payment operation. 
 userId|Integer|Identifier of the new user created and for which the order, invoice and payment were created. 
{table}

h4. PricingField

This data structure describes heterogeneous data that will be passed to the rules engine
in order to calculate prices and/or flag specific conditions that affect pricing:

{table}
 *Property name*|*Type*|*Description*
 name|String|Identifier of the pricing field. 
 position|Integer|(optional) 
 strValue|String|A multipurpose String value of the pricing field, which can be used  as deemed fit within the rules (for example, use the string value as a description for the Item). 
 dateValue|Date|Optional date value of the pricing field, which can be used as necessary by the rules (for example, to set the activeUntil date of the order). 
 intValue|Integer|Optional integer value of the pricing field, which can be used as necessary by the rules. 
 decimalValue|BigDecimal|Optional decimal value of the pricing field, which can be used as necessary by the rules (for example, to set a different price or apply as discount). 
 booleanValue|Boolean|Optional boolean value of the pricing field, which can be used as necessary by the rules. 
{table}

h3. Item Management Calls

Items are the building blocks of purchase orders. Items are usually managed from the GUI Web App since they don't have the 
level of activity of orders or payments. Use this service for integration with other applications (for example, an inventory system)
or when handling high volumes to get better throughput as compared to the Web Application. An item can have a simple price or a percentage price. 
Items with a simple price will simply add that price to the total of a purchase order. A percentage price will impact that
total by a percentage. Examples of items with percentage prices are taxes and interests.

h4. ItemDTOEx

{table}
 *Property name*|*Type*|*Description*
 currencyId|Integer|Identifier for the currency in which the item's price is expressed. See Appendix A for a list of acceptable values. 
 deleted|Integer|A flag that indicates if this record is logically deleted in the database. This allows for 'undo' of deletions. Valid values are: 0  the record is not deleted 1  the record is considered deleted. 
 entityId|Integer|Identifier for the entity to which this item belongs. 
 hasDecimals|Integer|An internal flag indicating whether the item accepts decimal quantities. Can have the following values: 0  No decimals, quantities are expressed as an integer, 1  Decimals allowed in quantity values. 
 id|Integer|A unique number that identifies this Item record. 
 orderLineTypeId|Integer|The order line type that this item will generate, such a 'taxes', or 'items'. 
 types|Integer[]|A list of type identifiers that indicates to which types (categories) this item belongs. An item must belong to at least one type. 
 defaultPrice|PriceModelWS|A default pricing model this Item follows. See PriceModelWS 
 description|String|Item description 
 glCode|String|General Ledger code for integration with Other systems like Accounting Systems. 
 number|String|This can be used to identify this item following an external coding system. For example, books can be identified by their ISBN codes. 
 percentage|BigDecimal|If this Item has percentage rate, that rate is specified using this field 
 price|BigDecimal|The price of this item or null if this is a percentage item. 
 promoCode|String|If this item is related to a promotion, this is the code that identifies the promotion. 
{table}

h4. PriceModelWS

{table}
 *Property name*|*Type*|*Description*
 a|b|c
{table}

h4. ItemTypeWS

{table}
 *Property name*|*Type*|*Description*
 description |String  |  Description for this item type. 
 id|Integer|Identifier of this item type. 
 orderLineTypeId|Integer|Type of order line for this item. See "Order Line Type Codes" in "Appendix A" for valid values for this field. 
{table}

h4. ValidatePurchaseWS

{table}
 *Property name*|*Type*|*Description*
 authorized|Boolean  |"true" if the validation has been authorized, "false" otherwise. 
 message|String[]|An array of messages detailing the result of the validation operation. 
 quantity|String|Quantity of the item that can be applied without exceeding the user's remaining credit limit or prepaid balance. 
 success|Boolean|"true" if the validation was successful, "false" otherwise. 
{table}

h3. Invoice Management Calls

The invoice management calls allow your application to query the system about
invoices, and to attempt to pay an invoice through a payment gateway. Invoices in
jBilling are, for the most part, read-only and are created based on purchase orders.
Invoices can be generated, however, for orders that have yet to be invoiced.

h4. InvoiceWS

{table}
 *Property name*|*Type*|*Description* 
 createDateTime|Date|This is the invoice date, which is assigned to it by the billing process when it is generated. 
 createTimeStamp|Date|A time stamp of when this invoice record was created. 
 dueDate|Date|The due date of this invoice. After this date, the invoice should have been paid. 
 lastReminder|Date|Date and time of when the latest reminder was issued for this invoice. 
 currencyId|Integer|Identifier of the currency in which the invoice's amounts are being expressed. See Appendix A for a list of all acceptable values. 
 delegatedInvoiceId|Integer|If this invoice has been included in another invoice (usually for lack of payment), this field will indicate to which invoice it has been delegated. 
 deleted|Integer|A flag that indicates if this record is logically deleted in the database. This allows for 'undo' of deletions. Valid values are: 0  the record is not deleted 1  the record is considered deleted. 
 id|Integer|A unique number that identifies this record. 
 inProcessPayment|Integer|A flag indicating if this invoice will be paid using automated payment (through a payment processor), or if it will be paid externally (for example, with a paper check). 
 isReview|Integer|This is an internal value that indicates if this invoice is not a 'real' invoice, but one that belongs to a review process. If '1', it means that it is not a real Invoice. 
 orders|Integer[]|A list of the ids of the purchase orders which have been included in this invoice. 
 overdueStep|Integer|This marks which step is this invoice in for the penalties (interests) process. 
 paymentAttempts|Integer|How many payment attempts have been done by the automated payment process to get this invoice paid. 
 payments|Integer[]|A list of ids of the payments that have been applied to this invoice. 
 statusId|Integer|A flag that indicates the status of this invoice. See section *Invoice Status Codes* on Annexure A for valid values for this field. 
 toProcess|Integer|This is '1' if the invoice will be considered by the billing process as unpaid. Otherwise it is '0' and the invoices is either paid or carried over to another invoice. 
 userId|Integer|The customer to whom this invoice belongs. 
 invoiceLines|InvoiceLineDTO[]|A list of objects representing each of this invoice's lines. 
 balance|String|The amount of this invoice that is yet to be paid. Can also be handled as a Java BigDecimal via the "getBalanceAsDecimal()" and "setBalanceAsDecimal()" methods. 
 carriedBalance|String|How much of the total belonging to previous unpaid invoices that have been delegated to this one. It can also be handled via the "getCarriedBalanceAsDecimal()" and "setCarriedBalanceAsDecimal()" methods. 
 customerNotes|String|Notes that are entered in a purchase order can be applied to an invoice. If that is the case, this field will have those user notes. 
 number|String|The invoice number, which is assigned to it from a 'preference' field (see the user guide for more information).  This is not the ID, which is guaranteed to be unique. 
 statusDescr|String|The status name of the Invoice status as determined from the field statusId 
 total|String|The total amount of this invoice. It can also be handled as a Java BigDecimal via the "getTotalAsDecimal()" and "setTotalAsDecimal()" methods. 
{table}

h4. InvoiceLineDTO

This data structure contains data relative to a single line of an invoice.

{table}
 *Property name*|*Type*|*Description* 
 amount|BigDecimal|The total amount for this line. Usually would follow the formula price * quantity.|	
 deleted|Integer|A flag that indicates if this record is logically deleted in the database. This allows for 'undo' of deletions.  Valid values are: 0  the record is not deleted 1  the record is considered deleted. 
 description|String|This description will be displayed in the invoice delivered to the customer. 
 id|Integer|A unique number that identifies this record. 
 isPercentage|Integer|Indicates whether the item referenced by this invoice line is a percentage item or not. This is used to aid how the order line is displayed to the customer. 
 itemId|Integer|Identifier of the item referenced by this invoice line. 
 price|BigDecimal|The pricing of a single unit of this item. 
 quantity|BigDecimal|The number of units of the item being invoiced. 
 sourceUserId|Integer|This field is useful only when many sub-accounts is invoiced together. This field would have the ID of the user that originally purchase an item. 
{table}

h3. Payment Management Calls

Payments play a crucial role in determining the status of a customer. For the system to
properly trace payments, they have to be linked to the invoices they are paying.
Payments not related to an invoice should be avoided; they are intended for initial
imports from legacy billing systems and exceptional circumstances. Arbitrary credit card
payment processing not linked to any invoice is possible, however.
There are three basic payment methods: Cheques, ACH and Credit Cards. Different objects are
used as fields of PaymentWS for each for these types. 
There are two different actions related to payments. One is to apply a payment. This
means that the payment has already been processed and accepted by the company.
Applying the payment will let the system know that a new payment has to be registered.
A common example is when the company has received and successfully deposited a
cheque. In this case, the system only has to apply the payment to the customer's
account.
A more comprehensive action is to process a payment. Processing a payment means
the company will submit the payment information to the system, then the system will
submit the payment to a payment process for its authorization in real-time, storing the
result of this operation. The caller will get the results of this authorization. The most
common example for this operation is a credit card payment.
In summary, the system can both request authorization of a payment and apply the
payment to the customer's account, or it can do only this last step.
The payment management calls will let you query the system for payments, and also
apply and submit a payment to get an invoice payed.

h3. PaymentWS

{table}
 *Property name*|*Type*|*Description* 
 ach|AchDTO|If this is a payment done with Automatic Clearing House (ACH), 
 this property contains the banking information needed. 
 amount|String|The amount of the payment operation. Can also be handled as a Java BigDecimal via the "getAmountAsDecimal()" and "setAmountAsDecimal()" methods. 
 authorization|PaymentAuthorizationDTO|Refund specific field. Contains the identifier of the authorization details for the refund. 
 balance|String|Balance of this payment. If greater than 0, this payment could pay part of another invoice. If 0, this payment has already been applied to an invoice, lowering the invoice's balance. It can also be handled as a Java BigDecimal via the "getBalanceAsDecimal()" and "setBalanceAsDecimal()" methods. 
 cheque|PaymentInfoChequeDTO|If this payment is done via check, this property contains information about the cheque, otherwise it contains "null". 
 createDatetime|Date|Date in which this payment record was created. 
 creditCard|CreditCardDTO|If this is a credit card payment, this property contains information about the credit card, otherwise it contains "null". 
 currencyId|Integer|Identifier of the currency in which the payment is being made. See Appendix A for a list of acceptable values. 
 deleted|Integer|Delete flag. "1" if this record has been deleted, "0" otherwise. 
 attempt|Integer|Number of the attempt to process this payment. 
 id|Integer|Unique identifier of the payment record. 
 invoiceIds|Integer[]|Contains the list of invoices this payment is paying. 
 isPreauth|Integer|"1" if this payment is a preauthorization, "0" otherwise. 
 isRefund|Integer|"1" if this payment constitutes a refund operation, "0" otherwise. 
 method|String|Name of the payment method used. 
 paymentDate|Date|Date of the payment. 
 paymentId|Integer|Refund specific field. When a refund is to be issued, this field holds the identifier of the payment that is to be refunded. 
 paymentMethodId|Integer|Identifier of the payment method. Refer to Appendix A for a list of acceptable values. 
 paymentNotes|String|Any notes related to this payment for e.g. relevant invoiceId can be added to notes or any relevant information. 
 paymentPeriod|Integer|Optional Payment period identifier 
 resultId|Integer|Identifier of the result of the payment attempt. Refer to Appendix A for a list of acceptable values. 
 updateDatetime|Date|Date in which this payment record was last updated. 
 userId|Integer|Identifier of the user this payment record belongs to. 
{table}

h3. PaymentInfoChequeDTO

{table}
 *Property name*|*Type*|*Description* 
 id|Integer|The unique identifier of this record.|	
 bank|String|The name of the bank this cheque's account belongs to. 
 number|String|The cheque's number. 
 date|Date|The cheque's date. 
{table}

h3. AchDTO

{table}
 *Property name*|*Type*|*Description* 
 abcRouting|String|ABA routing number|	
 accountName|String|The account name 
 accountType|Integer|If this is chequings or a savings account. 
 bankAccount|String|The account number. 
 bankName|String|The bank name. 
 id|Integer|The unique identifier of this record. 
{table}

h3. PaymentAuthorizationDTO

{table}
 *Property name*|*Type*|*Description* 
 id|Integer|Unique identifier of the payment authorization. 
 processor|String|Name of the payment processor. 
 code1|String|Request code number 1. 
 code2|String|Request code number 2. 
 code3|String|Request code number 3. 
 approvalCode|String|Approval code provided by the processor. 
 AVS|String|A code with the results of address verification. 
 transactionId|String|Identifier of the processor transaction. 
 MD5|String|Hash for the transaction. 
 cardCode |String |Payment card code. 
 createDate |Date |The creation date for this payment authorization record. 
 responseMessage |String |The response provided by the processor. 
{table}

h3. PaymentAuthorizationDTOEx

This data structure contains data about a payment authorization process. It extends the PaymentAuthorizationDTO structure (see above). 
Thus, it shares all the same fields plus the following:

{table}
 *Property name*|*Type*|*Description* 
 result |Boolean |"true" if the authorization succeeded, "false" otherwise. 
{table}



h2. API Service Calls

The Service APIs/Calls are grouped according to functional area or data entities in jBilling, for example: 
User Management APIs, Orders, Items, etc. All data contained in the Client API data structures can be accessed by means 
of the "getter" and "setter" methods of each property (i.e., @getFaxNumber()@ and @setFaxNumber()@ provide access to the _faxNumber_ property). 
When describing data structures, this guide always provides the property name. This reference is equally useful for those 
planning to use the web services directly, or for those that will be using the jBilling Client API. For non-Java languages, the data 
structures will look slightly different: they are described in the WSDL descriptor and how that is translated to each language varies. 
For those using the jBilling Client API from a Java application, the data structures can be used directly as classes.

{note}
For a finer coverage of the SOAP support, refer to the WSDL file or use a SOAP
introspection tool (such as SoapUI). All the SOAP methods, however, share the same
name, parameters and functionality as their API counterparts.
{note}

All service calls provided by the API are covered in the Web Services API Reference docs. 

Please refer to the client/Web Services API from here: [WebServices|API Reference.html].




h1. Appendix A

h2. Constants Reference

h3. Language Codes
{(wiki-table)table}
 *Code*|*Name*
  1|English 
  2|Portuguese 
{table}

h3. Currency Codes
{table}
 *Currency name* |*Currency code*| *ISO Code* |*Symbol Country*
 1 |United States Dollar |USD |US$| USA 
 2 |Canadian Dollar |CAD |C$ |Canada 
 3 |Euro| EUR| <pre>&euro;</pre> | Europe 
 4 |Yen| JPY |  |Japan 
 5 |Pound Sterling |GBP |  | United Kingdom 
 6 |South Korean Won| KRW |South Korea 
 7 |Swiss Franc| CHF |Sf |Switzerland 
 8 |Swedish Krona| SEK |SeK |Sweden 
 9 |Singapore Dollar |SGD |S$ |Singapore 
 10|Ringgit |MYR |M$ |Malaysia 
 11|Australian Dollar |AUD| $ |Australia 
{table}

h3. Role Codes
{table}
 *Code* | *Meaning* 
 1 | Internal 
 2 | Super User 
 3 | Clerk 
 4 | Partner 
 5 | Customer 
{table}

h3. User Status Codes
{table}
 *Code* | *Meaning*
 1 | Active 
 2 | Overdue 
 3 | Overdue 2 
 4 | Overdue 3 
 5 | Suspended 
 6 | Suspended 2 
 7 | Suspended 3 
 8 | Deleted 
{table}

h3. Subscriber Status Codes
{table}
 *Code* | *Meaning* 
 1 | Active 
 2 | Pending Subscription 
 3 | Unsubscribed 
 4 | Pending Expiration 
 5 | Expired 
 6 | Nonsubscriber 
{table}

h3. Payment Method Codes
{table}
 *Code* | *Meaning* 
 1 | Cheque 
 2 | Visa 
 3 | MasterCard 
 4 | AMEX 
 5 | ACH 
 6 | Discovery 
 7 | Diners 
 8 | PayPal 
{table}

h3. Order Status Codes
{table}
 *Code* | *Meaning* 
 1 | Active 
 2 | Finished 
 3 | Suspended 
 4 | Suspended (auto) 
{table}

h3. Order Billing Type Codes
{table}
 *Code* | *Meaning* 
 1 | Pre-paid 
 2 | Post-paid 
{table}

h3. Order Line Type Codes
{table}
 *Code* | *Meaning* 
 1 | Item 
 2 | Tax 
 3 | Penalty 
{table}

h3. Invoice Status Codes
{table}
 *Code* | *Meaning* 
 1 | Paid 
 2 | Unpaid 
 3 | Unpaid, balance carried to a new invoice. 
{table}

h3. Period units (units of time)
{table}
 *Unit* | *Meaning* 
 1 | Month 
 2 | Week 
 3 | Day 
 4 | Year 
{table}

h3. Payment results
{table}
 *Result* | *Meaning* 
 1 | Successful 
 2 | Failed 
 3 | Payment gateway not available 
 4 | Manually entered (payment gateway not involved, such as a cheque). 
{table}

h3. Dynamic Balance Codes
{table}
 *Code* | *Meaning* 
 1 | No dynamic balance 
 2 | Pre paid 
 3 | Credit limit 
{table}

h3. Provisioning Status Codes
{table}
 *Code*| *Meaning* 
 1 | Active 
 2 | Inactive 
 3 | Pending Active 
 4 | Pending Inactive 
 5 | Failed 
 6 | Unavailable 
{table}

h3. Automatic Payment Type
{table}
 *Code* |  *Meaning* 
 1 | Credit Card 
 2 | ACH 
 3 | Cheque 
{table}

h3. Invoice Delivery Method
{table}
 *Code* |  *Meaning* 
 1 | Email 
 2 | Paper 
 3 | Both Email & Paper 
{table}